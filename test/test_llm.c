#include <criterion/criterion.h>

#include "mellow/mellow.h"
#include "internals.h"
#include "utils.h"

// These tests were generated by an LLM

Test(llm, coalesce_updates_free_list_head)
{
    void *a = mw_malloc(32);
    void *b = mw_malloc(32);
    void *c = mw_malloc(32);
    mw_free(b);  // free_list -> b
    mw_free(a);  // coalesce a+b (head must change)
    cr_assert_not_null(mw_internals.free_list);
    check_valid_free_list();
    heap_layout_t layout = {
        {AVAILABLE, .payload_size = 64 + 2 * sizeof(size_t), .payload = NULL},
        {OCCUPIED,  .payload_size = 32,                      .payload = c   },
        {AVAILABLE, .payload_size = -1,                      .payload = NULL},
    };
    ASSERT_HEAP_EQ(layout);
}

Test(llm, coalesced_block_reuse)
{
    void *a = mw_malloc(32);
    void *b = mw_malloc(32);
    void *c = mw_malloc(32);
    mw_free(a);
    mw_free(b);  // merged block now large enough
    void *p = mw_malloc(64);
    cr_assert_eq(p, a);
    check_valid_free_list();
    heap_layout_t layout = {
        // We gain 2 void* sizes since one pair of prev/next isn't used
        {OCCUPIED,  .payload_size = 64 + 2 * sizeof(void *), .payload = a   },
        {OCCUPIED,  .payload_size = 32,                      .payload = c   },
        {AVAILABLE, .payload_size = -1,                      .payload = NULL},
    };
    ASSERT_HEAP_EQ(layout);
}

Test(llm, free_does_not_corrupt_neighbors)
{
    char *a = mw_malloc(32);
    char *b = mw_malloc(32);
    char *c = mw_malloc(32);
    memset(a, 'A', 32);
    memset(b, 'B', 32);
    memset(c, 'C', 32);
    mw_free(b);
    for (int i = 0; i < 32; i++)
    {
        cr_assert_eq(a[i], 'A');
        cr_assert_eq(c[i], 'C');
    }
    check_valid_free_list();
}

Test(llm, free_all_then_reallocate)
{
    void *a = mw_malloc(64);
    void *b = mw_malloc(64);
    void *c = mw_malloc(64);
    mw_free(a);
    mw_free(b);
    mw_free(c);
    void *p = mw_malloc(128);
    cr_assert_eq(p, a);
    check_valid_free_list();
}

Test(llm, large_block_middle_removal)
{
    void *a = mw_malloc(MW_HEAP_CHUNK_SIZE * 2 - 124);
    void *b = mw_malloc(MW_HEAP_CHUNK_SIZE * 2 - 124);
    void *c = mw_malloc(MW_HEAP_CHUNK_SIZE * 2 - 124);
    mw_free(b);
    cr_assert_not_null(mw_internals.large_blocks);
    cr_assert_null(mw_internals.large_blocks->prev);
    cr_assert_not_null(mw_internals.large_blocks->next);
    cr_assert_null(mw_internals.large_blocks->next->next);
    mw_free(a);
    mw_free(c);
    cr_assert_null(mw_internals.large_blocks);
}

Test(llm, no_cross_chunk_coalesce, .disabled = true)
{
    size_t big = MW_HEAP_CHUNK_SIZE / 2;
    void  *a = mw_malloc(big);
    void  *b = mw_malloc(big);
    void  *c = mw_malloc(big);  // forces second chunk
    mw_free(b);
    mw_free(c);
    (void)a;
    check_valid_free_list();
}
